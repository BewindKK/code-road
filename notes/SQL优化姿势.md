## 硬件配置

硬件方面的优化可以有 对磁盘进行扩容、将机械硬盘换为SSD 等等。但这个优化手段成本最高，见效也较小。

## 系统配置

系统选择、保证内存读取（Buffer Pool）、降低磁盘写入次数（日志）

### 系统选择

系统通常使用Linux作为服务端的系统，本地开发的话可以随意。Linux 系统版本和 MySQL 版本选择稳定的版本即可。

### 保证从内存读取

MySQL 会在内存中保存一定的数据， LRU（最近最少使用）算法

尽可能扩大内存中的数据量，从内存中取数据可以提升MySQL性能

LRU 算法针对的是 MySQL 内存中的结构，这里有个区域叫 **Buffer Pool（缓冲池）** 作为数据读写的缓冲区
域。把这个区域进行相应的扩大即可提升性能

### 数据预热

数据预热相当于将磁盘中的数据提前放入 BufferPool内存缓冲池内。一定程度提升了读取速度。

### 降低磁盘的写入次数

（1）增大 redo log，减少落盘次数：redo log 是重做日志，用于保证数据的一致，减少落盘相当于减少了系统 IO 操作。

（2）通用查询日志、慢查询日志可以不开 ，binlog 可开启。

### 系统调优参数

## SQL语句优化

执行器执行之前的分析器，优化器阶段完成的

### 那要怎么找到MySQL执行慢的语句呢？

#### 慢查询日志

MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句，这个阈值通常默认为10s，也可以按需配置。

Mysql是默认关闭慢查询日志的，所以需要我们手动开启

#### 那找到慢语句之后，怎么查看它的执行计划？explain

使用explain命令，它可以获取到MySQL语句的执行计划 ，包括会**使用的索引、扫描行数、表如何连接**等信息。

可以看出是否是我们使用的预期索引，进而进行调整重点关注的是type，最直观的反映出SQL的性能。

**type：查询数据时采用的方式**

ALL 全表（性能最差）
index 基于索引的全表
range 范围 （< > in）
ref 非唯一索引单值查询
const 使用主键或者唯一索引等值查询

##### explain你记得哪些字段，分别有什么含义？

id 

在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id 
select_type 
SELECT关键字对应的那个查询的类型

table 
表名

partitions 
匹配的分区信息

**type** 
**针对单表的访问方法**

**possible_keys** 
**可能用到的索引**

**key** 
**实际上使用的索引**

**key_len** 
**实际使用到的索引长度**

ref 
当使用索引列等值查询时，与索引列进行等值匹配的对象信息

**rows** 
**预估的需要读取的记录条数**

filtered 
某个表经过搜索条件过滤后剩余记录条数的百分比

Extra 
一些额外的信息 

###### 统计这个统计的行数就是完全对的么？

近似值

MySQL中数据的单位都是页，MySQL又采用了采样统计的方法，采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

数据是一直在变的，所以索引的统计信息也是会变的，会根据一个阈值，重新做统计。

#### 怎么调整呢？

数据是在不断变化的，同时执行器也有判断失误的情况，MySQL有时候的执行计划，会出乎意料。

这种情况，我们可以使用语句强行指定索引：

select xx from table_name force index (index_name) where ...

#### 排除缓存干扰

###### MySQL8.0之前数据库有缓存

SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。

**为什么缓存会失效**

每次请求的查询语句和结果都会以key-value的形式缓存在内存中的

缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空，其实我们很少存在不更新表



### 建索引

#### **字段的数值有唯一性的限制**(唯一性索引，或者主键索引)

如果某个字段是唯一性的，就可以直接创建**唯一性索引，或者主键索引**。这样可以更快速地通过该索引来确定某条记录。

> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。(来源: Alibaba)
>
> 说明:不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。

#### 频繁作为where查询条件的字段(普通索引)

某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建**普通索引**就可以大幅提升数据查询的效率

#### 经常**GROUP BY** **和** **ORDER BY** **的列**(联合索引)

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 **对分组或者排序的字段进行索引** 。如果待排序的列有多个，那么可以在这些列上建立 **组合索引 。** 

**待排序有多个：**

1. 分别建立索引
   1. 只会用最前面的索引
2. 建立联合索引
   1. 在Mysql8.0中可以给待排序的列指定升序或降序
   2. 5.7无所谓，因为最后都会忽略

#### **UPDATE****、****DELETE** **的** **WHERE** **条件列**

对数据按照某个条件进行查询后再进行UPDATE或DELETE的操作，如果对WHERE 字段创建了索引，就能大幅提升效率。**原理**是因为我们需要``先根据WHERE条件列检索出来这条记录，然后再对它进行更新或删除``。如果进行更新的时候，**更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。**

#### **DISTINCT** **字段需要创建索引**

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。

#### **多表** **JOIN** **连接操作时，创建索引注意事项**

首先， 连接表的**数量尽量不要超过 3 张** ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。

其次， **对 WHERE 条件创建索引** ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。

最后， **对用于连接的字段创建索引** ，并且该字段在多张表中的 **类型必须一致** 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

#### **使用列的类型小的创建索引**

**类型大小**指的就是该类型表示的**数据范围的大小。**

以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。

**原因：**

- 数据类型越小，在查询时进行的比较操作越快
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的**主键来说更加适用**，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。

#### **使用字符串前缀创建索引**(前缀索引)

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么**两个问题:**|

- B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在**索引中占用的存储空间越大。**
- 如果B+树索引中索引列存储的字符串很长，那在做**字符串比较时会占用更多的时间。**

我们可以通过截取字段的前面一部分内容建立索引，这个就叫**前缀索引**。这样在查找记录时虽然不能精确的定位到记录的位置，但是能**定位到相应前缀所在的位置**，然后**根据前缀相同的记录的主键值回表查询完整的字符串值**。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。



问题是，截取多少呢?截取得多了，达不到节省索引存储空间的目的;截取得少了，重复内容太多,字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢?

**先看一下字段在全部数据中的选择度:**

```sql
select count(distinct addrels ) / count(* ) from shop ;
```

通过不同长度去计算，与全表的选择性对比:

```sql
count(distinct left(列名，索引长度))/count(*)
```

![image-20220404105023953](../../../TyporaAssets/SQL优化姿势/image-20220404105023953.png)

【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，**长度为 20 的索引**，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

 

#### **区分度高**(散列性高)的列适合作为索引

列的**基数**指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，在记录行数一定的情况下』**列的基数越大，该列中的值越分散;**列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。**最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。**

可以使用公式 select count(distinct a)/count(*) from t1计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。

**拓展:联合索引把区分度高(散列性高)的列放在前面。**通过取字串，反转，从后往前比较

#### **使用最频繁的列放到联合索引的左侧**

这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。

#### **在多个字段都要创建索引的情况下，联合索引优于单值索引** 



#### **限制索引的数目** 

 在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量**不超过6个**。原因:

- 每个索引都需要占用**磁盘空间**，索引越多，需要的磁盘空间就越大。
- 索引会影响**INSERT、DELETE、UPDATE等语句的性能**，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
- 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的**索引来进行评估**，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会**增加MySQL优化器生成执行计划时间**，降低查询性能。

#### **哪些情况不适合创建索引** 

##### **在where中使用不到的字段，不要设置索引**

##### **数据量小的表最好不要使用索引**

结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。

 

##### **有大量重复数据的列上不要建立索引**

在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的“性别"字段上只有“男”与“女"两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。

##### **避免对经常更新的表创建过多的索引** 

第一层含义:频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。

第二层含义:避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。|

 

##### **不建议用无序的值作为索引**

B+树默认升序

例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。

#### **删除不再使用或者很少使用的索引** 



##### **不要定义冗余或重复的索引** 

**冗余索引**

有时候有意或者无意的就对同一个列创建了多个索引，比如: index(a,b,c)相当于index(a)、index(a,b)index(a,b,c)。

维护这个索引只会增加维护的成本，并不会对搜索有什么好处。

 

**重复索引**

我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。

#### 覆盖索引

如果在我们建立的索引上就已经有我们需要的字段，就不需要回表了

覆盖索引可以减少树的搜索次数，显著提升查询性能，

所以使用覆盖索引是一个常用的性能优化手段。

#### 索引下推

select * from itemcenter where name like '北%' and size=22 and age = 20;

所以这个语句在搜索索引树的时候，只能用 “敖”，

找到第一个满足条件的记录ID1，当然，这还不错，总比全表扫描要好。

在MySQL 5.6之前，只能从ID1开始一个个回表，到主键索引上找出数据行，再对比字段值。

MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的
字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

#### 唯一索引普通索引选择难题

##### 核心是需要回答到change buffer

###### change buffer是什么

####### 当需要更新一个数据页时，如果数据页在内存中就直接
更新，而如果这个数据页还没有在内存中的话，在不影
响数据一致性的前提下，InooDB会将这些更新操作缓
存在change buffer中，这样就不需要从磁盘中读入这
个数据页了。

####### 在下次查询需要访问这个数据页的时候，将数据页读入
内存，然后执行change buffer中与这个页有关的操
作，通过这种方式就能保证这个数据逻辑的正确性。

####### 虽然名字叫作change buffer，实际上它是可以持久化
的数据。也就是说，change buffer在内存中有拷贝，
也会被写入到磁盘上。

####### change buffer用的是buffer pool里的内存，因此不能无限增大

###### 将change buffer中的操作应用到原数据页，得到最新

结果的过程称为merge。

###### 除了访问这个数据页会触发merge外，系统有后台线程

会定期merge。在数据库正常关闭（shutdown）的过
程中，也会执行merge操作。

###### 什么条件下可以使用change buffer呢？

####### 唯一索引

######## 所有的更新操作都要先判断这个操作是否违反唯一性约束。

######## 要判断表中是否存在这个数据，而这必须要将数据页读
入内存才能判断，如果都已经读入到内存了，那直接更
新内存会更快，就没必要使用change buffer了。

######## 唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

###### change buffer使用场景

####### 写多读少的业务来说，页面在写完以后马上被访问到的
概率比较小，此时change buffer的使用效果最好，这
种业务模型常见的就是账单类、日志类的系统。

#### 前缀索引

##### 定义字符串的一部分作为索引，默认地，如果你创建索

引的语句不指定前缀长度，那么索引就会包含整个字符
串。

##### 是否可以建立一个区分度很高的前缀索引，达到优化和

节约空间的目的呢？

###### 使用前缀索引，定义好长度，就可以做到既节省空间，

又不用额外增加太多的查询成本。

##### 回表

###### 前缀索引，即使你的联合索引已经包涵了相关信息，他

还是会回表，因为他不确定你到底是不是一个完整的信
息

##### 很长的字段，想做索引我们怎么去优化他呢？

###### 磁盘占用问题：

####### 索引选取的越长，占用的磁盘空间就越大，相同的数据
页能放下的索引值就越少，搜索的效率也就会越低。

###### 区分度高低

####### 采用倒序，或者删减字符串建立自己的区分度

###### 解决

####### 增大区分度

####### REVERSE（）函数翻转一下，区分度可能就高了。

####### 前面的数据都相同是没有任何区分度的，可以substrin
g()函数截取掉前面的，然后建立索引。

###### 函数

####### 调用函数也是一次开销

### 索引失效

#### 函数操作

##### 如果对字段做了函数计算，就用不上索引了

###### 对索引字段做函数操作，可能会破坏索引值的有序性，

因此优化器就决定放弃走树搜索功能。

###### 优化器并不是要放弃使用这个索引。

###### 取巧的方法

####### 比如 select * from tradelog where id + 1 = 10000
 就走不上索引，select * from tradelog where id = 9
999就可以。

#### 隐式类型转换

##### select * from t where id = 1

如果id是字符类型的，1是数字类型的，你用explain会
发现走了全表扫描，根本用不上索引

###### 为什么

####### 本质上还是用了函数

####### 因为MySQL底层会对你的比较进行转换，相当于加了
 CAST( id AS signed int) 这样的一个函数，上面说过
函数会导致走不上索引。

#### 隐式字符编码转换

##### 本质上还是调用了函数，索引失效

##### 如果两个表的字符集不一样，一个是utf8mb4，一个是

utf8，因为utf8mb4是utf8的超集，所以一旦两个字符
比较，就会转换为utf8mb4再比较。

###### 转换的过程相当于加了CONVERT(id USING utf8mb4)函数

### mysql突然卡顿：flush

#### 可能是MySQLflush

##### redo log我们对数据库操作的日志，他是在内存中的，

每次操作一旦写了redo log就会立马返回结果，但是这
个redo log总会找个时间去更新到磁盘，这个操作就是
flush。

###### 脏页和干净页

####### 脏页

######## 在更新之前，当内存数据页跟磁盘数据页内容不一致的
时候，我们称这个内存页

####### 干净页

######## 内存数据写入到磁盘后，内存和磁盘上的数据页的内容
就一致了

##### 那什么时候会flush呢？

###### InnoDB的redo log写满了，这时候系统会停止所有更

新操作，把checkpoint往前推进，redo log留出空间
可以继续写。

###### 系统内存不足，当需要新的内存页，而内存不够用的时

候，就要淘汰一些数据页，空出内存给别的数据页使
用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。

###### 难道不能直接把内存淘汰掉，下次需要请求的时候，从

磁盘读入数据页，然后拿redo log出来应用不就行了？

####### 从性能考虑的

###### MySQL认为系统“空闲”的时候，只要有机会就刷一点“脏页”。

###### MySQL正常关闭，这时候，MySQL会把内存的脏页都

flush到磁盘上，这样下次MySQL启动的时候，就可以
直接从磁盘上读数据，启动速度会很快。

##### 把握flush的时机呢

###### 刷脏页的时候，旁边如果也是脏页，会一起刷掉的，并

且如果周围还有脏页，这个连带责任制会一直蔓延，这
种情况其实在机械硬盘时代比较好，一次IO就解决了所
有问题，

### SQL规范性检查

#### select

##### UDF用户自定义函数

###### SQL语句的select后面使用了自定义函数UDF，SQL返

回多少行，那么UDF函数就会被调用多少次，这是非常
影响性能的。

###### #getOrderNo是用户自定义一个函数用户来根据order_sn来获取订单编号

select id, payment_id, order_sn, getOrderNo(order_sn) 
from payment_transaction
 where status = 1 and create_time between '2020-10-01 10:00:00' and '2020-10-02 10:00:00';

##### text类型检查

###### 如果select出现text类型的字段，就会消耗大量的网络

和IO带宽，由于返回的内容过大超过max_allowed_packet
设置会导致程序报错，需要评估谨慎使用。

##### group_concat谨慎使用

###### gorup_concat是一个字符串聚合函数，会影响SQL的

响应时间，如果返回的值过大超过了max_allowed_packet
设置会导致程序报错。

##### 内联子查询

###### 在select后面有子查询的情况称为内联子查询，SQL返

回多少行，子查询就需要执行过多少次，严重影响SQL性能。

###### select id,(

select rule_name from member_rule limit 1
) as rule_name, member_id, member_type, member_name, status 
 from member_info m 
where status = 1 and create_time between '2020-09-02 10:00:00' and '2020-10-01 10:00:00';

#### from检查

##### 表的链接方式

###### 在MySQL中不建议使用Left Join，即使ON过滤条件列

索引，一些情况也不会走索引，导致大量的数据行被扫
描，SQL性能变得很差，同时要清楚ON和Where的区
别。

####### ON和where区别

###### 子查询

####### 由于MySQL的基于成本的优化器CBO对子查询的处理
能力比较弱，不建议使用子查询，可以改写成Inner Join。

#### where检查

##### 索引列被运算

##### 类型转换

##### 列字符集

#### group by检查

##### 前缀索引

###### group by后面的列有索引，索引可以消除排序带来的

CPU开销，如果是前缀索引，是不能消除排序的。

##### 函数运算

###### 假设需要统计某月每天的新增用户量，参考如下SQL语

句，虽然可以走create_time的索引，但是不能消除排
序，可以考虑冗余一个字段stats_date date类型来解
决这种问题。

###### select DATE_FORMAT(create_time, '%Y-%m-%d'), count(*) from users where create_time between '2020-09-01 00:00:00' and '2020-09-30 23:59:59' group by DATE_FORMAT(create_time, '%Y-%m-%d');

#### order by检查

##### 前缀索引

###### order by后面的列有索引，索引可以消除排序带来的

CPU开销，如果是前缀索引，是不能消除排序的。

##### 字段顺序

###### 排序字段顺序，asc/desc升降要跟索引保持一致，充分

利用索引的有序性来消除排序带来的CPU开销。

#### limit检查

##### limit m,n要慎重

###### 对于limit m, n分页查询，越往后面翻页即m越大的情

况下SQL的耗时会越来越长，对于这种应该先取出主键
id，然后通过主键id跟原表进行Join关联查询。

## 频率控制优化

## 分库分表



## 表结构设计

### 设计中间表

#### 设计中间表，一般针对于统计分析功能，或者实时性不

高的需求（报表统计，数据分析等系统）。

### 设计冗余字段

#### 为减少关联查询，创建合理的冗余字段（创建冗余字段

还需要注意数据一致性问题）。这里分库分表时较为常
用。

### 拆表

#### 对于字段太多的大表，考虑拆表（比如一个表有100多

个字段） 对于表中经常不被使用的字段或者存储数据
比较多的字段，考虑拆表。

### 主键优化

#### 每张表建议都要有一个主键（主键索引），而且主键类

型最好是int类型，建议自增主键（分布式系统的情况
下建议雪花算法）

### 字段的设计

#### 数据库中的表越小，在它上面执行的查询也就会越快。

#### 使用可以存下数据最小的数据类型，合适即可

尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED；
VARCHAR的长度只分配真正需要的空间；
对于某些文本字段，比如"省份"或者"性别"，使用枚举或整数代替字符串类型；在MySQL中， ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多
尽量使用TIMESTAMP而非DATETIME；
单表不要有太多字段，建议在20以内；
尽可能使用 not null 定义字段，null 占用4字节空间，这样在将来执行查询的时候，数据库不用去比较NULL值。
用整型来存IP。
尽量少用 text 类型，非用不可时最好考虑拆表

### 字段属性

#### NOT NULL属性

##### 根据业务含义，尽量将字段都添加上NOT NULL DEFAULT 

VALUE属性，如果列值存储了大量的NULL，会影响索引的稳定性。

#### DEFAULT属性

##### 在创建表的时候，建议每个字段尽量都有默认值，禁止

DEFAULT NULL，而是对字段类型填充响应的默认值。

#### COMMENT属性

##### 字段的备注要能明确该字段的作用，尤其是某些表示状

态的字段，要显式的写出该字段所有可能的状态数值以
及该数值的含义。

#### TEXT类型

##### 不建议使用Text数据类型，一方面由于传输大量的数据

包可能会超过max_allowed_packet设置导致程序报
错，
另一方面表上的DML操作都会变的很慢，建议采
用es或者对象存储OSS来存储和检索。
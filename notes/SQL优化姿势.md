## 硬件配置

硬件方面的优化可以有 对磁盘进行扩容、将机械硬盘换为SSD 等等。但这个优化手段成本最高，见效也较小。

## 系统配置

系统选择、保证内存读取（Buffer Pool）、降低磁盘写入次数（日志）

### 系统选择

系统通常使用Linux作为服务端的系统，本地开发的话可以随意。Linux 系统版本和 MySQL 版本选择稳定的版本即可。

### 保证从内存读取

MySQL 会在内存中保存一定的数据， LRU（最近最少使用）算法

尽可能扩大内存中的数据量，从内存中取数据可以提升MySQL性能

LRU 算法针对的是 MySQL 内存中的结构，这里有个区域叫 **Buffer Pool（缓冲池）** 作为数据读写的缓冲区
域。把这个区域进行相应的扩大即可提升性能

### 数据预热

数据预热相当于将磁盘中的数据提前放入 BufferPool内存缓冲池内。一定程度提升了读取速度。

对于 InnoDB，这里提供一份预热 SQL 脚本：

```sql
#mysql5.7版本中，如果DISTINCT和order by一起使用将会报3065错误，sql语句无法执行。这是由于5.7版本语法比之前版本语法要求更加严格导致的。
#推荐在mysql的配置文件my.cnf文件(linux)/my.ini文件(window) 的mysqld中增加或者修改sql_model配置选项
#sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
#重启后生效
SELECT DISTINCT
    CONCAT('SELECT ',rowlist,' FROM ',db,'.',tb,
    ' ORDER BY ',rowlist,';') selectSql
    FROM
    (
        SELECT
            engine,table_schema db,table_name tb,
            index_name,GROUP_CONCAT(column_name ORDER BY seq_in_index) rowlist
        FROM
        (
            SELECT
                B.engine,A.table_schema,A.table_name,
                A.index_name,A.column_name,A.seq_in_index
            FROM
                information_schema.statistics A INNER JOIN
                (
                    SELECT engine,table_schema,table_name
                    FROM information_schema.tables WHERE
                    engine='InnoDB'
                ) B USING (table_schema,table_name)
            WHERE B.table_schema NOT IN ('information_schema','mysql')
            ORDER BY table_schema,table_name,index_name,seq_in_index
        ) A
        GROUP BY table_schema,table_name,index_name
    ) AA 
ORDER BY db,tb;
```



### 降低磁盘的写入次数

（1）增大 redo log，减少落盘次数：

redo log 是重做日志，用于保证数据的一致，减少落盘相当于减少了系统 IO 操作。

（2）通用查询日志、慢查询日志可以不开 ，binlog 可开启。

**查看相关参数的命令**：

```sql
# 慢查询日志
show variables like 'slow_query_log%'
# 通用查询日志
show variables like '%general%';
# 错误日志
show variables like '%log_error%'
# 二进制日志
show variables like '%binlog%';
```

3）写 redo log 策略 innodb_flush_log_at_trx_commit 设置为 0 或 2

对于不需要强一致性的业务，可以设置为 0 或 2。

- 0：每隔 1 秒写日志文件和刷盘操作（写日志文件 LogBuffer --> OS cache，刷盘 OS cache --> 磁盘文件），最多丢失 1 秒数据
- 1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁 IO 操作
- 2：事务提交，立刻写日志文件，每隔 1 秒钟进行刷盘操作

### 系统调优参数

**back_log**

back_log值可以指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500。

**wait_timeout**

数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时。

**max_user_connection**

最大连接数，默认为0无上限，最好设一个合理上限。

**thread_concurrency**

并发线程数，设为CPU核数的两倍。

**skip_name_resolve**

禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问。

**key_buffer_size**

索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like 'key_read%'，保证key_reads / key_read_requests在0.1%以下最好。

**innodb_buffer_pool_size**

缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like 'Innodb_buffer_pool_read%'，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests越高越好。

**innodb_additional_mem_pool_size**

InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小。

**innodb_log_buffer_size**

InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB。

**query_cache_size**

缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们数据变化非常频繁的情况下，使用Query Cache可能得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大。可以通过命令show status like 'Qcache_%'查看目前系统Query catch使用大小。

**read_buffer_size**

MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小来提高其性能。

**sort_buffer_size**

MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小。

**read_rnd_buffer_size**

MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。

**record_buffer**

每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值。

**thread_cache_size**

保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的。

**table_cache**

类似于thread_cache _size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM。

## 表结构设计

### 设计中间表

设计中间表，一般针对于统计分析功能，或者实时性不高的需求（报表统计，数据分析等系统）。

### 设计冗余字段

为减少关联查询，创建合理的冗余字段（创建冗余字段还需要注意数据一致性问题）。这里分库分表时较为常
用。

### 拆表

对于字段太多的大表，考虑拆表（比如一个表有100多个字段） 对于表中经常不被使用的字段或者存储数据
比较多的字段，考虑拆表。

### 主键优化

每张表建议都要有一个主键（主键索引），而且主键类型最好是int类型，建议自增主键（分布式系统的情况
下建议雪花算法）

### 字段的设计

- 数据库中的表越小，在它上面执行的查询也就会越快。
- 使用可以存下数据最小的数据类型，合适即可
- 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED；
  VARCHAR的长度只分配真正需要的空间；
- 对于某些文本字段，比如"省份"或者"性别"，使用枚举或整数代替字符串类型；
- 在MySQL中， ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多
- 尽量使用TIMESTAMP而非DATETIME；
- 单表不要有太多字段，建议在20以内；
- 尽可能使用 not null 定义字段，null 占用4字节空间，这样在将来执行查询的时候，数据库不用去比较NULL值。
- 用整型来存IP。
- 尽量少用 text 类型，非用不可时最好考虑拆表

## SQL语句优化

执行器执行之前的分析器，优化器阶段完成的

### 排除缓存干扰

MySQL8.0之前我们的数据库是存在缓存，我们在执行SQL的时候，记得加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。

**为什么缓存会失效，而且是经常失效。**

如果我们当前的MySQL版本支持缓存而且我们又开启了缓存，那每次请求的查询语句和结果都会以key-value的形式缓存在内存中的，缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空

### 那要怎么找到MySQL执行慢的语句呢？

#### 慢查询日志

MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句，这个阈值通常默认为10s，也可以按需配置。

Mysql是默认关闭慢查询日志的，所以需要我们手动开启

```sql
# 开启全局慢查询日志
SET global slow_query_log = ON;
# 设置慢查询日志文件名
SET global slow_query_log_file = 'slow-query.log';
# 记录未使用索引的SQL
SET global log_queries_not_using_indexes = ON;
# 慢查询的时间阈值，默认10秒
SET long_query_time = 10;
```

#### 那找到慢语句之后，怎么查看它的执行计划？explain

使用explain命令，它可以获取到MySQL语句的执行计划 ，包括会**使用的索引、扫描行数、表如何连接**等信息。

可以看出是否是我们使用的预期索引，进而进行调整重点关注的是type，最直观的反映出SQL的性能。

**type：查询数据时采用的方式**

ALL 全表（性能最差）
index 基于索引的全表
range 范围 （< > in）
ref 非唯一索引单值查询
const 使用主键或者唯一索引等值查询

##### explain你记得哪些字段，分别有什么含义？

这里对explain的结果进行简单说明：

- select_type：查询类型

- - SIMPLE 简单查询
  - PRIMARY 最外层查询
  - UNION union后续查询
  - SUBQUERY 子查询

- type：查询数据时采用的方式

- - ALL 全表**（性能最差）**
  - index 基于索引的全表
  - range 范围 （< > in）
  - ref 非唯一索引单值查询
  - const 使用主键或者唯一索引等值查询

- possible_keys：可能用到的索引

- key：真正用到的索引

- rows：预估扫描多少行记录

- key_len：使用了索引的字节数

- Extra：额外信息

- - Using where 索引回表
  - Using index 索引直接满足条件
  - Using filesort 需要排序
  - Using temprorary 使用到临时表

id 

在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id 
select_type 
SELECT关键字对应的那个查询的类型

table 
表名

partitions 
匹配的分区信息

**type** 
**针对单表的访问方法**

**possible_keys** 
**可能用到的索引**

**key** 
**实际上使用的索引**

**key_len** 
**实际使用到的索引长度**

ref 
当使用索引列等值查询时，与索引列进行等值匹配的对象信息

**rows** 
**预估的需要读取的记录条数**

filtered 
某个表经过搜索条件过滤后剩余记录条数的百分比

Extra 
一些额外的信息 

###### 统计这个统计的行数就是完全对的么？

近似值

MySQL中数据的单位都是页，MySQL又采用了采样统计的方法，采样统计的时候，InnoDB默认会选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。

数据是一直在变的，所以索引的统计信息也是会变的，会根据一个阈值，重新做统计。

#### 怎么调整呢？

数据是在不断变化的，同时执行器也有判断失误的情况，MySQL有时候的执行计划，会出乎意料。

这种情况，我们可以使用语句强行指定索引：

select xx from table_name force index (index_name) where ...

#### 排除缓存干扰

###### MySQL8.0之前数据库有缓存

SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。

**为什么缓存会失效**

每次请求的查询语句和结果都会以key-value的形式缓存在内存中的

缓存失效比较频繁的原因就是，只要我们一对表进行更新，那这个表所有的缓存都会被清空，其实我们很少存在不更新表



### 建索引

#### **字段的数值有唯一性的限制**(唯一性索引，或者主键索引)

如果某个字段是唯一性的，就可以直接创建**唯一性索引，或者主键索引**。这样可以更快速地通过该索引来确定某条记录。

> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。(来源: Alibaba)
>
> 说明:不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的。

#### 频繁作为where查询条件的字段(普通索引)

某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建**普通索引**就可以大幅提升数据查询的效率

#### 经常**GROUP BY** **和** **ORDER BY** **的列**(联合索引)

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要 **对分组或者排序的字段进行索引** 。如果待排序的列有多个，那么可以在这些列上建立 **组合索引 。** 

**待排序有多个：**

1. 分别建立索引
   1. 只会用最前面的索引
2. 建立联合索引
   1. 在Mysql8.0中可以给待排序的列指定升序或降序
   2. 5.7无所谓，因为最后都会忽略

#### UPDATE、DELETE **的** **WHERE** **条件列**

对数据按照某个条件进行查询后再进行UPDATE或DELETE的操作，如果对WHERE 字段创建了索引，就能大幅提升效率。**原理**是因为我们需要``先根据WHERE条件列检索出来这条记录，然后再对它进行更新或删除``。如果进行更新的时候，**更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。**

#### **DISTINCT** **字段需要创建索引**

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。

#### **多表** **JOIN** **连接操作时，创建索引注意事项**

首先， 连接表的**数量尽量不要超过 3 张** ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。

其次， **对 WHERE 条件创建索引** ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。

最后， **对用于连接的字段创建索引** ，并且该字段在多张表中的 **类型必须一致** 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

#### **使用列的类型小的创建索引**

**类型大小**指的就是该类型表示的**数据范围的大小。**

以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。

**原因：**

- 数据类型越小，在查询时进行的比较操作越快
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的**主键来说更加适用**，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。

#### **使用字符串前缀创建索引**(前缀索引)

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么**两个问题:**|

- B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在**索引中占用的存储空间越大。**
- 如果B+树索引中索引列存储的字符串很长，那在做**字符串比较时会占用更多的时间。**

我们可以通过截取字段的前面一部分内容建立索引，这个就叫**前缀索引**。这样在查找记录时虽然不能精确的定位到记录的位置，但是能**定位到相应前缀所在的位置**，然后**根据前缀相同的记录的主键值回表查询完整的字符串值**。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。



问题是，截取多少呢?截取得多了，达不到节省索引存储空间的目的;截取得少了，重复内容太多,字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢?

**先看一下字段在全部数据中的选择度:**

```sql
select count(distinct addrels ) / count(* ) from shop ;
```

通过不同长度去计算，与全表的选择性对比:

```sql
count(distinct left(列名，索引长度))/count(*)
```

![image-20220404105023953](../../../TyporaAssets/SQL优化姿势/image-20220404105023953.png)

【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，**长度为 20 的索引**，区分度会 高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

 

#### **区分度高**(散列性高)的列适合作为索引

列的**基数**指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，在记录行数一定的情况下』**列的基数越大，该列中的值越分散;**列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。**最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。**

可以使用公式 select count(distinct a)/count(*) from t1计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。

**拓展:联合索引把区分度高(散列性高)的列放在前面。**通过取字串，反转，从后往前比较

#### **使用最频繁的列放到联合索引的左侧**

这样也可以较少的建立一些索引。同时，由于"最左前缀原则"，可以增加联合索引的使用率。

#### **在多个字段都要创建索引的情况下，联合索引优于单值索引** 



#### **限制索引的数目** 

 在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量**不超过6个**。原因:

- 每个索引都需要占用**磁盘空间**，索引越多，需要的磁盘空间就越大。
- 索引会影响**INSERT、DELETE、UPDATE等语句的性能**，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
- 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的**索引来进行评估**，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会**增加MySQL优化器生成执行计划时间**，降低查询性能。

#### **哪些情况不适合创建索引** 

##### **在where中使用不到的字段，不要设置索引**

##### **数据量小的表最好不要使用索引**

结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。

 

##### **有大量重复数据的列上不要建立索引**

在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的“性别"字段上只有“男”与“女"两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。

##### **避免对经常更新的表创建过多的索引** 

第一层含义:频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。

第二层含义:避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。|

 

##### **不建议用无序的值作为索引**

B+树默认升序

例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。

#### **删除不再使用或者很少使用的索引** 



##### **不要定义冗余或重复的索引** 

**冗余索引**

有时候有意或者无意的就对同一个列创建了多个索引，比如: index(a,b,c)相当于index(a)、index(a,b)index(a,b,c)。

维护这个索引只会增加维护的成本，并不会对搜索有什么好处。

 

**重复索引**

我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。

#### 覆盖索引

如果在我们建立的索引上就已经有我们需要的字段，就不需要回表了

覆盖索引可以减少树的搜索次数，显著提升查询性能，

所以使用覆盖索引是一个常用的性能优化手段。

```sql
select itemId from itemCenter where size between 1 and 6
```

因为**商品id itemId一般都是主键**，在**size索引**上肯定会有我们这个值，这个时候就不需要回主键表去查询id信息了。

#### 索引下推

select * from itemcenter where name like '北%' and size=22 and age = 20;

所以这个语句在搜索索引树的时候，只能用 “敖”，

找到第一个满足条件的记录ID1，当然，这还不错，总比全表扫描要好。

在MySQL 5.6之前，只能从ID1开始一个个回表，到主键索引上找出数据行，再对比字段值。

MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以**在索引遍历过程中，对索引中包含的**
**字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。**

#### 唯一索引普通索引选择难题

核心是需要回答到change buffer

**change buffer是什么**

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。

在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。

虽然名字叫作change buffer，实际上它是可以持久化的数据。也就是说，change buffer在内存中有拷贝，也会被写入到磁盘上。

change buffer用的是buffer pool里的内存，因此不能无限增大

将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。

除了访问这个数据页会触发merge外，系统有后台线程会定期merge。在数据库正常关闭（shutdown）的过程中，也会执行merge操作。

**什么条件下可以使用change buffer呢？**

唯一索引

要判断表中是否存在这个数据，而这必须要将数据页读入内存才能判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

**change buffer使用场景**

写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，这种业务模型常见的就是账单类、日志类的系统。

#### 前缀索引

定义字符串的一部分作为索引，默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

**是否可以建立一个区分度很高的前缀索引，达到优化和节约空间的目的呢？**

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

##### 回表

前缀索引，即使你的联合索引已经包涵了相关信息，他还是会回表，因为他不确定你到底是不是一个完整的信
息

**很长的字段，想做索引我们怎么去优化他呢？**

**磁盘占用问题：**

索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。

**区分度高低**

采用倒序，或者删减字符串建立自己的区分度

**解决**

增大区分度

REVERSE（）函数翻转一下，区分度可能就高了。

前面的数据都相同是没有任何区分度的，可以substring()函数截取掉前面的，然后建立索引。

**函数**

调用函数也是一次开销

### 索引失效

#### 函数操作

如果对字段做了函数计算，就用不上索引了

对索引字段做函数操作，可能会破坏索引值的有序性，

因此优化器就决定放弃走树搜索功能。

###### 优化器并不是要放弃使用这个索引。

###### 取巧的方法

比如 select * from tradelog where id + 1 = 10000就走不上索引，select * from tradelog where id = 9999就可以。

#### 隐式类型转换

select * from t where id = 1

如果id是字符类型的，1是数字类型的，你用explain会发现走了全表扫描，根本用不上索引

###### 为什么

本质上还是用了函数

因为MySQL底层会对你的比较进行转换，相当于加了CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引。

#### 隐式字符编码转换

**本质上还是调用了函数，索引失效**

如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。

转换的过程相当于加了CONVERT(id USING utf8mb4)函数

### MySQL索引凭什么让查询效率提高这么多？

你能从计算机层面开始说一下一个索引数据加载的流程么？（就是想让我聊IO）

**MySQL的索引本质上是一种数据结构**

**磁盘IO和预读：**

> 先说一下磁盘IO，磁盘读取数据靠的是机械运动，每一次读取数据需要**寻道、寻点、拷贝到内存**三步操作。
>
> **寻道**时间是磁臂移动到指定磁道所需要的时间，一般在5ms以下；
>
> **寻点**是从磁道中找到数据存在的那个点，平均时间是半圈时间，如果是一个7200转/min的磁盘，寻点时间平均是600000/7200/2=4.17ms；
>
> **拷贝到内存**的时间很快，和前面两个时间比起来可以忽略不计，所以一**次IO的时间平均是在9ms左右**。听起来很快，但数据库百万级别的数据过一遍就达到了9000s，显然就是灾难级别的了。

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了**预读的优化**，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内**，因为当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。

**每一次IO读取的数据我们称之为一页(page)**，具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO。

那我们想要优化数据库查询，就要**尽量减少磁盘的IO操作**，所以就出现了索引。

**B+Tree索引**

`B+Tree`是在`B-Tree`基础上的一种优化，使其更适合实现外存储索引结构。

在B+Tree中，所有数据记录节点都是按照**键值大小顺序**存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

只需要进行三次的IO操作就可以从10亿条数据中找到我们想要的数据

### 写SQL技巧

#### SQL语句尽可能简单

一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库。

#### 对于连续数值，使用 BETWEEN 不用 IN

SELECT id FROM t WHERE num BETWEEN 1 AND 5；

#### SQL 语句中 IN 包含的值不应过多

MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。如果数值较多，需要在内存进行排序操作，产生的消耗也是比较大的。

#### SELECT 语句必须指明字段名称

SELECT * 增加很多不必要的消耗（CPU、IO、内存、网络带宽）；减少了使用覆盖索引的可能性。

#### 当只需要一条数据的时候，使用 limit 1

limit 相当于截断查询。

例如：对于select * from user limit 1; 虽然进行了全表扫描，但是limit截断了全表扫描，从0开始取了1条数据。

#### 排序字段加索引

排序的字段建立索引在排序的时候也会用到

#### 如果限制条件中其他字段没有索引，尽量少用or

#### 尽量用 union all 代替 union

union和union all的差别就在于union会对数据做一个distinct的动作，而这个distanct动作的速度则取决于现有数据的数量，数量越大则时间也越慢。而对于几个数据集，要确保数据集之间的数据互相不重复，基本是O(n)的算法复杂度。

#### 区分 in 和 exists、not in 和 not exists

如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以**IN适合于外表大而内表小**的情况；**EXISTS适合于外表小而内表大的情况**。

#### 使用合理的分页方式以提高分页的效率

limit m n，其中的m偏移量尽量小。m越大查询越慢。

#### 避免使用 % 前缀模糊查询

例如：like '%name'或者like '%name%'，这种查询会导致**索引失效**而进行全表扫描。但是可以使用like 'name%'，这种会使用到索引。

### SQL规范性检查

#### select

##### UDF用户自定义函数

SQL语句的select后面使用了自定义函数UDF，SQL返回多少行，那么UDF函数就会被调用多少次，这是非常
影响性能的。

#getOrderNo是用户自定义一个函数用户来根据order_sn来获取订单编号

select id, payment_id, order_sn, getOrderNo(order_sn) 
from payment_transaction
 where status = 1 and create_time between '2020-10-01 10:00:00' and '2020-10-02 10:00:00';

##### text类型检查

如果select出现text类型的字段，就会消耗大量的网络和IO带宽，由于返回的内容过大超过max_allowed_packet设置会导致程序报错，需要评估谨慎使用。

##### group_concat谨慎使用

gorup_concat是一个字符串聚合函数，会影响SQL的响应时间，如果返回的值过大超过了max_allowed_packet设置会导致程序报错。

##### 内联子查询

在select后面有子查询的情况称为内联子查询，SQL返回多少行，子查询就需要执行过多少次，严重影响SQL性能。

###### select id,(

select rule_name from member_rule limit 1
) as rule_name, member_id, member_type, member_name, status 
 from member_info m 
where status = 1 and create_time between '2020-09-02 10:00:00' and '2020-10-01 10:00:00';

#### from检查

##### 表的链接方式

在MySQL中不建议使用Left Join，即使ON过滤条件列索引，一些情况也不会走索引，导致大量的数据行被扫描，SQL性能变得很差，同时要清楚ON和Where的区别。



###### 子查询

由于MySQL的基于成本的优化器CBO对子查询的处理能力比较弱，不建议使用子查询，可以改写成Inner Join。

#### where检查

索引列被运算

类型转换

列字符集

#### group by检查

##### 前缀索引

group by后面的列有索引，索引可以消除排序带来的CPU开销，如果是前缀索引，是不能消除排序的。

##### 函数运算

假设需要统计某月每天的新增用户量，参考如下SQL语句，虽然可以走create_time的索引，但是不能消除排
序，可以考虑冗余一个字段stats_date date类型来解决这种问题。

###### select DATE_FORMAT(create_time, '%Y-%m-%d'), count(*) from users where create_time between '2020-09-01 00:00:00' and '2020-09-30 23:59:59' group by DATE_FORMAT(create_time, '%Y-%m-%d');

#### order by检查

##### 前缀索引

order by后面的列有索引，索引可以消除排序带来的CPU开销，如果是前缀索引，是不能消除排序的。

##### 字段顺序

排序字段顺序，asc/desc升降要跟索引保持一致，充分利用索引的有序性来消除排序带来的CPU开销。

#### limit检查

##### limit m,n要慎重

对于limit m, n分页查询，越往后面翻页即m越大的情况下SQL的耗时会越来越长，对于这种应该先取出主键id，然后通过主键id跟原表进行Join关联查询。

**如何解决limit分页?**

使用between...and；

使用where限定条件，进行过滤

## 频率控制优化

## 分库分表



## 参考

https://mp.weixin.qq.com/s/CP-kJNuaPzKQWyzLzvRRAg

https://github.com/AobingJava/JavaFamily

